---
title: "Discipline, Markets, and Rust â€” My First Week in the $1M Plan"
seoTitle: "First Week in $1M Plan: Lessons Learned"
seoDescription: "A personal journey into market trading and Rust coding, exploring key concepts like order books, liquidity, and risk management, with lessons learned"
datePublished: Tue Oct 28 2025 22:28:58 GMT+0000 (Coordinated Universal Time)
cuid: cmhb526wq000302l8b57a0alt
slug: first-week-progress
cover: https://cdn.hashnode.com/res/hashnode/image/stock/unsplash/fiXLQXAhCfk/upload/ddcd922e3ff51df39679539b2e8c2543.jpeg
tags: rust-programming, tradingstrategies

---

Two weeks back, I decided to change my life. I wanted to stop overthinking and start *building* â€” skills, money, and confidence.  
Itâ€™s a 1-month â€œMillion $ Planâ€ where I learn trading foundations + market data coding with Rust.

But truth be told, Week 1 took me two weeks. Not because it was complex â€” but because I was inconsistent.  
My discipline is weak, my eyes strain easily, and I often lose focus. Some days I just couldnâ€™t look at the screen.  
The U.S. job market stress didnâ€™t help either. The pressure of â€œnot doing enoughâ€ made me spiral into doing nothing.

Still, I reminded myself â€” slow progress &gt; no progress.  
And I made it through Week 1.

Hereâ€™s what I learned.

---

## ðŸ“˜ Order Books, Bidâ€“Ask & Liquidity

**Definition:**  
An **order book** is a real-time list of all buy (bid) and sell (ask) orders for an asset.  
The **bid price** shows what buyers are willing to pay, and the **ask price** shows what sellers want.  
The difference between them is the **spread**, and itâ€™s a live measure of market activity.

**What I understood:**  
The order book is like the *heartbeat* of a market.  
When the spread is narrow, thereâ€™s energy â€” buyers and sellers are actively meeting in the middle.  
When itâ€™s wide, the market feels tired or uncertain.

**Liquidity** means how easily you can buy or sell without affecting the price.  
A deep order book = smooth flow.  
A thin book = turbulence.

Good liquidity felt like water â€” the more there is, the easier it is to swim.

---

## ðŸ’¸ Slippage

**Definition:**  
Slippage is the difference between the price you expect and the price you actually get when your trade executes.

**Two ways to see slippage:**

| **View** | **Description** | **Cause** |
| --- | --- | --- |
| **Price-based view** | Difference between expected and actual execution price | Market moves or latency |
| **Order book view** | Your trade â€œeatsâ€ through several price levels, raising (or lowering) the average fill price | Thin order book / low liquidity |

**What I understood:**  
Slippage happens when you rush into a trade while the market canâ€™t handle your speed.  
Itâ€™s like asking for 10 mangoes at â‚¹100 each, but only 5 are available. The rest cost â‚¹105 â€” so your *average* price goes up.  
Impatience costs money.

---

## ðŸ§¾ Market, Limit & Stop Orders

**Market Order** â†’ Executes immediately at best available price.  
**Limit Order** â†’ Executes only when price reaches your limit.  
**Stop Order** â†’ Turns into a market order once a trigger (stop price) is hit.

**What I understood:**

* Market = â€œNow.â€ Fast but expensive.
    
* Limit = â€œOnly if this price.â€ Slow but precise.
    
* Stop = â€œExit if it hurts.â€ Your automatic panic button.
    

Stop orders felt like seatbelts â€” you donâ€™t notice them when things go well, but youâ€™re grateful when they save you.

---

## ðŸ“Š Moving Averages (MA) - SMA, EMA & Crossovers

**Definition:**  
A **Moving Average (MA)** smooths out short-term price noise and shows the overall trend.

1ï¸âƒ£ **Simple Moving Average (SMA)**  
The Simple Moving Average (SMA) is the average of closing prices over a period.

**What I understood:**  
MAs are like a calm teacher summarizing the class â€” they filter out the chatter.  
Short MAs react fast but are noisy; long MAs react slow but steady.

**Rust Code:**

```rust
fn simple_moving_average(prices: &[f64], period: usize) -> Option<f64> {
    if prices.len() < period {
        return None;
    }
    let sum: f64 = prices[prices.len() - period..].iter().sum();
    Some(sum / period as f64)
}

fn main() {
    let btc_prices = vec![64000.0, 64200.0, 63950.0, 64100.0, 64300.0];
    if let Some(sma) = simple_moving_average(&btc_prices, 3) {
        println!("3-day SMA: {:.2}", sma);
    } else {
        println!("Not enough data");
    }
}
```

It felt nice to see numbers turn into something *interpretable*. Rust made it elegant and safe.

2ï¸âƒ£ **Exponential Moving Average (EMA)**

**Formula:**  
`EMAâ‚œ = (Priceâ‚œ Ã— k) + EMAâ‚œâ‚‹â‚ Ã— (1 âˆ’ k)` where `k = 2 / (N + 1)`

**What I understood:**  
EMA reacts faster to recent prices than SMA.  
If SMA is a steady teacher, EMA is a student who pays attention to todayâ€™s mood.

---

3ï¸âƒ£ **Crossover Signals**

**Definition:**  
When a short-term MA crosses a long-term MA, it can indicate trend shifts:

* **Golden Cross** â†’ Short MA crosses above Long MA â†’ Bullish
    
* **Death Cross** â†’ Short MA crosses below Long MA â†’ Bearish
    

**What I understood:**  
Crossovers felt like traffic signals of momentum â€” green to go, red to slow.  
Theyâ€™re not always right, but they give structure in chaos.

---

## ðŸ“‰ RSI & MACD

**Relative Strength Index (RSI)**

**Formula:** `RSI = 100 âˆ’ [100 / (1 + RS)]` where RS = (average gains)/(average losses)

**What I understood:**  
RSI is a fatigue meter â€” shows when the market is overbought (&gt; 70) or oversold (&lt; 30).  
It helps avoid buying into excitement or selling into panic.

**Moving Average Convergence Divergence (MACD)**

**Definition:**  
`MACD = EMA(12) âˆ’ EMA(26)`  
`Signal Line = EMA(9) of MACD`  
Histogram = MACD âˆ’ Signal Line

**What I understood:**  
The MACD line tracks momentum; the Signal line smooths it.  
When MACD crosses above Signal â†’ momentum turns bullish.  
Below â†’ bearish.  
The histogram visualizes that difference like heartbeat spikes of momentum.

Example scenario: BTC MACD turns positive while RSI moves from 40 â†’ 55 â†’ likely trend reversal brewing.

---

## ðŸ›¡ï¸ Risk Management

**Definition:**  
Risk management means protecting your capital while aiming for returns. It includes:

* **Position sizing:** how much you risk per trade.
    
* **Stop loss:** when to exit.
    
* **Riskâ€“Reward ratio:** whether the trade is even worth it.
    

**What I understood:**  
This part felt like cricket â€” you canâ€™t play cover drives every ball.  
Itâ€™s not about hitting sixes; itâ€™s about staying at the crease.  
Risk management is defense â€” not exciting, but it keeps you alive.

---

## âš™ï¸ Fetching BTC Prices (REST API + Rust)

**Definition:**  
REST APIs allow you to fetch real-time data from servers.  
Using `reqwest` crate in Rust, I fetched live Bitcoin prices from Coinbase API.

**Code:**

```rust
use reqwest;
use serde::Deserialize;

#[derive(Deserialize)]
struct PriceData {
    amount: String,
    base: String,
    currency: String,
}

#[derive(Deserialize)]
struct ApiResponse {
    data: PriceData,
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let resp = reqwest::get("https://api.coinbase.com/v2/prices/BTC-USD/spot")
        .await?
        .json::<ApiResponse>()
        .await?;
    println!("{}: ${}", resp.data.base, resp.data.amount);
    Ok(())
}
```

**What I understood:**  
It felt like touching the market pulse directly â€” data flowing from real exchanges into my terminal.  
Rustâ€™s async felt smooth and robust.

---

## ðŸ§° Built a CLI Tool for Live Prices

After fetching data, I wrapped it into a CLI tool that fetches live crypto prices instantly.  
It takes coin symbols (like BTC or ETH) and prints real-time prices.

ðŸ”— [GitHub Repo â€“ crypto-price-fetcher](https://github.com/noworry-b-still/crypto-price-fetcher)

**What I understood:**  
Building small tools compounds learning.  
This CLI is my first step toward algo trading automation â€” small, but mine.

---

## ðŸ¦€ Rustlings Progress

Alongside trading, I continued **Rustlings** exercises up to *lifetimes*.  
Those exercises drilled ownership, borrowing, and references deep into my brain.  
At first, the compiler felt strict â€” but now it feels like a mentor who stops you from breaking your own code.

**What I understood:**  
Lifetimes teach patience â€” every reference has a story.  
Rust makes you think about memory like a trader thinks about risk: *careful and precise.*

---

## ðŸ§  Reflection

This week taught me two truths:

* The market rewards discipline.
    
* Rust rewards clarity.
    

Both punish carelessness.  
I may be slow, but Iâ€™m building something solid â€” one concept, one line, one trade at a time.