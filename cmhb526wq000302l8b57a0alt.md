---
title: "Discipline, Markets, and Rust — My First Week in the $1M Plan"
seoTitle: "First Week in $1M Plan: Lessons Learned"
seoDescription: "A personal journey into market trading and Rust coding, exploring key concepts like order books, liquidity, and risk management, with lessons learned"
datePublished: Tue Oct 28 2025 22:28:58 GMT+0000 (Coordinated Universal Time)
cuid: cmhb526wq000302l8b57a0alt
slug: first-week-progress
cover: https://cdn.hashnode.com/res/hashnode/image/stock/unsplash/fiXLQXAhCfk/upload/ddcd922e3ff51df39679539b2e8c2543.jpeg
tags: rust-programming, tradingstrategies

---

Two weeks back, I decided to change my life. I wanted to stop overthinking and start *building* — skills, money, and confidence.  
It’s a 1-month “Million $ Plan” where I learn trading foundations + market data coding with Rust.

But truth be told, Week 1 took me two weeks. Not because it was complex — but because I was inconsistent.  
My discipline is weak, my eyes strain easily, and I often lose focus. Some days I just couldn’t look at the screen.  
The U.S. job market stress didn’t help either. The pressure of “not doing enough” made me spiral into doing nothing.

Still, I reminded myself — slow progress &gt; no progress.  
And I made it through Week 1.

Here’s what I learned.

---

## 📘 Order Books, Bid–Ask & Liquidity

**Definition:**  
An **order book** is a real-time list of all buy (bid) and sell (ask) orders for an asset.  
The **bid price** shows what buyers are willing to pay, and the **ask price** shows what sellers want.  
The difference between them is the **spread**, and it’s a live measure of market activity.

**What I understood:**  
The order book is like the *heartbeat* of a market.  
When the spread is narrow, there’s energy — buyers and sellers are actively meeting in the middle.  
When it’s wide, the market feels tired or uncertain.

**Liquidity** means how easily you can buy or sell without affecting the price.  
A deep order book = smooth flow.  
A thin book = turbulence.

Good liquidity felt like water — the more there is, the easier it is to swim.

---

## 💸 Slippage

**Definition:**  
Slippage is the difference between the price you expect and the price you actually get when your trade executes.

**Two ways to see slippage:**

| **View** | **Description** | **Cause** |
| --- | --- | --- |
| **Price-based view** | Difference between expected and actual execution price | Market moves or latency |
| **Order book view** | Your trade “eats” through several price levels, raising (or lowering) the average fill price | Thin order book / low liquidity |

**What I understood:**  
Slippage happens when you rush into a trade while the market can’t handle your speed.  
It’s like asking for 10 mangoes at ₹100 each, but only 5 are available. The rest cost ₹105 — so your *average* price goes up.  
Impatience costs money.

---

## 🧾 Market, Limit & Stop Orders

**Market Order** → Executes immediately at best available price.  
**Limit Order** → Executes only when price reaches your limit.  
**Stop Order** → Turns into a market order once a trigger (stop price) is hit.

**What I understood:**

* Market = “Now.” Fast but expensive.
    
* Limit = “Only if this price.” Slow but precise.
    
* Stop = “Exit if it hurts.” Your automatic panic button.
    

Stop orders felt like seatbelts — you don’t notice them when things go well, but you’re grateful when they save you.

---

## 📊 Moving Averages (MA) - SMA, EMA & Crossovers

**Definition:**  
A **Moving Average (MA)** smooths out short-term price noise and shows the overall trend.

1️⃣ **Simple Moving Average (SMA)**  
The Simple Moving Average (SMA) is the average of closing prices over a period.

**What I understood:**  
MAs are like a calm teacher summarizing the class — they filter out the chatter.  
Short MAs react fast but are noisy; long MAs react slow but steady.

**Rust Code:**

```rust
fn simple_moving_average(prices: &[f64], period: usize) -> Option<f64> {
    if prices.len() < period {
        return None;
    }
    let sum: f64 = prices[prices.len() - period..].iter().sum();
    Some(sum / period as f64)
}

fn main() {
    let btc_prices = vec![64000.0, 64200.0, 63950.0, 64100.0, 64300.0];
    if let Some(sma) = simple_moving_average(&btc_prices, 3) {
        println!("3-day SMA: {:.2}", sma);
    } else {
        println!("Not enough data");
    }
}
```

It felt nice to see numbers turn into something *interpretable*. Rust made it elegant and safe.

2️⃣ **Exponential Moving Average (EMA)**

**Formula:**  
`EMAₜ = (Priceₜ × k) + EMAₜ₋₁ × (1 − k)` where `k = 2 / (N + 1)`

**What I understood:**  
EMA reacts faster to recent prices than SMA.  
If SMA is a steady teacher, EMA is a student who pays attention to today’s mood.

---

3️⃣ **Crossover Signals**

**Definition:**  
When a short-term MA crosses a long-term MA, it can indicate trend shifts:

* **Golden Cross** → Short MA crosses above Long MA → Bullish
    
* **Death Cross** → Short MA crosses below Long MA → Bearish
    

**What I understood:**  
Crossovers felt like traffic signals of momentum — green to go, red to slow.  
They’re not always right, but they give structure in chaos.

---

## 📉 RSI & MACD

**Relative Strength Index (RSI)**

**Formula:** `RSI = 100 − [100 / (1 + RS)]` where RS = (average gains)/(average losses)

**What I understood:**  
RSI is a fatigue meter — shows when the market is overbought (&gt; 70) or oversold (&lt; 30).  
It helps avoid buying into excitement or selling into panic.

**Moving Average Convergence Divergence (MACD)**

**Definition:**  
`MACD = EMA(12) − EMA(26)`  
`Signal Line = EMA(9) of MACD`  
Histogram = MACD − Signal Line

**What I understood:**  
The MACD line tracks momentum; the Signal line smooths it.  
When MACD crosses above Signal → momentum turns bullish.  
Below → bearish.  
The histogram visualizes that difference like heartbeat spikes of momentum.

Example scenario: BTC MACD turns positive while RSI moves from 40 → 55 → likely trend reversal brewing.

---

## 🛡️ Risk Management

**Definition:**  
Risk management means protecting your capital while aiming for returns. It includes:

* **Position sizing:** how much you risk per trade.
    
* **Stop loss:** when to exit.
    
* **Risk–Reward ratio:** whether the trade is even worth it.
    

**What I understood:**  
This part felt like cricket — you can’t play cover drives every ball.  
It’s not about hitting sixes; it’s about staying at the crease.  
Risk management is defense — not exciting, but it keeps you alive.

---

## ⚙️ Fetching BTC Prices (REST API + Rust)

**Definition:**  
REST APIs allow you to fetch real-time data from servers.  
Using `reqwest` crate in Rust, I fetched live Bitcoin prices from Coinbase API.

**Code:**

```rust
use reqwest;
use serde::Deserialize;

#[derive(Deserialize)]
struct PriceData {
    amount: String,
    base: String,
    currency: String,
}

#[derive(Deserialize)]
struct ApiResponse {
    data: PriceData,
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let resp = reqwest::get("https://api.coinbase.com/v2/prices/BTC-USD/spot")
        .await?
        .json::<ApiResponse>()
        .await?;
    println!("{}: ${}", resp.data.base, resp.data.amount);
    Ok(())
}
```

**What I understood:**  
It felt like touching the market pulse directly — data flowing from real exchanges into my terminal.  
Rust’s async felt smooth and robust.

---

## 🧰 Built a CLI Tool for Live Prices

After fetching data, I wrapped it into a CLI tool that fetches live crypto prices instantly.  
It takes coin symbols (like BTC or ETH) and prints real-time prices.

🔗 [GitHub Repo – crypto-price-fetcher](https://github.com/noworry-b-still/crypto-price-fetcher)

**What I understood:**  
Building small tools compounds learning.  
This CLI is my first step toward algo trading automation — small, but mine.

---

## 🦀 Rustlings Progress

Alongside trading, I continued **Rustlings** exercises up to *lifetimes*.  
Those exercises drilled ownership, borrowing, and references deep into my brain.  
At first, the compiler felt strict — but now it feels like a mentor who stops you from breaking your own code.

**What I understood:**  
Lifetimes teach patience — every reference has a story.  
Rust makes you think about memory like a trader thinks about risk: *careful and precise.*

---

## 🧠 Reflection

This week taught me two truths:

* The market rewards discipline.
    
* Rust rewards clarity.
    

Both punish carelessness.  
I may be slow, but I’m building something solid — one concept, one line, one trade at a time.